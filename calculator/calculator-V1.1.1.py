# -*- coding: utf-8 -*-
"""
@author: mastercoder1323
some error messages were generated by Gemini AI [https://gemini.google.com/app/']
"""

from tkinter import *
import math
# Make Window
window = Tk()
window.title("MC1323 Calculator V1.1.0")
window.geometry("400x500")
# Title
titleFrame = Frame(border=5, bg='black')
title = Label(
    titleFrame,
    text="Welcome to MC1323 Calculator",
    bg = 'black',
    fg = 'white',
    font=("Arial", 15)
)
title.pack(side=LEFT)
exitB=Button(titleFrame, text='X', bg='black', fg='white', font=("Arial", 15), command=window.destroy).pack(side=RIGHT)
titleFrame.pack(fill=X, side=TOP)
# Num Entry In Its Frame
numFrame = Frame(border=5)
num1 = Entry(
    width = 15,
    master=numFrame
)
num2 = Entry(
    width = 15,
    master=numFrame
)
Label(
    text='First Number:',
    master=numFrame
).pack(side=LEFT)
num1.pack(side=LEFT)
num2.pack(side=RIGHT)
Label(
    text='Second Number:',
    master=numFrame
).pack(side=RIGHT)
numFrame.pack(fill=X)

# Options
options = Frame()
Label(options,text='Options:', font=('Ariel', 12, 'bold')).pack(side=TOP)
accumulate = IntVar()
Checkbutton(
    options,
    border=5,
    text="Accumulate",  # Label displayed near the checkbox
    variable=accumulate,  # Link the checkbox to the variable
    onvalue=1,  # Set value to 1 when checked
    offvalue=0,  # Set value to 0 when unchecked
).pack(side=LEFT)
inverse = IntVar()
Checkbutton(
    options,
    border=5,
    text="Inverse Function",  # Label displayed near the checkbox
    variable=inverse,  # Link the checkbox to the variable
    onvalue=1,  # Set value to 1 when checked
    offvalue=0,  # Set value to 0 when unchecked
).pack(side=LEFT)

# Result
result = Text(wrap=WORD)

# Buttons & Their Functions & Their Frame
btnFrame = Frame(borderwidth=10)
btnFrame2 = Frame(borderwidth=10)
def roundToFive(value):
  formatted_string = f"{value:.5f}"
  return float(formatted_string)
def addition(n1,n2):
    try:
        resultN = float(n1.get()) + float(n2.get())
        returnValue = [f'\n{n1.get()} + {n2.get()} = {str(resultN)}', resultN]
        return returnValue
    except ValueError:
        return ['\n Error: This is Addition! Do It Yourself!', n1.get()]
    
def subtraction(n1,n2):
    try:
        resultN = float(n1.get()) - float(n2.get())
        returnValue = [f'\n{n1.get()} - {n2.get()} = {str(resultN)}', resultN]
        return returnValue
    except ValueError:
        return ['\n Error: You get an F for breaking subtraction, how do you even break subtraction!', n1.get()]
    
def multiplication(n1,n2):
    try:
        resultN = float(n1.get()) * float(n2.get())
        returnValue = [f'\n{n1.get()} X {n2.get()} = {str(resultN)}', resultN]
        return returnValue
    except ValueError:
        return ['\n Error: Are you multipliing "Me" X "You"!', n1.get()]
    
def division(n1,n2):
    try:
        resultN = float(n1.get()) / float(n2.get())
        returnValue = [f'\n{n1.get()} / {n2.get()} = {str(resultN)}', resultN]
        return returnValue
    except ValueError:
        return ['\n Error: Try dividing "this" by "that" and then use numbers, with no letters!', n1.get()]
    except ZeroDivisionError:
        return ['\nError: Uh oh, dividing by zero is like trying to use the Force on an empty fridge. It just doesn\'t work! May the odds be ever in your favor for future calculations.']

def exponent(n1,n2):
    try:
        resultN = float(n1.get()) ** float(n2.get())
        returnValue = [f'\n{n1.get()} ^ {n2.get()} = {str(resultN)}', resultN]
        return returnValue
    except ValueError:
        return ['\n Error: What did you put in? Tell Me NOW!', n1.get()]
    except OverflowError:
        return ['\nError: Whoa there, seems your numbers are bigger than the universe can handle! Try using smaller numbers or a more powerful calculator (like the one in your head, not me).', n1.get()]
    
def rooting(n1,n2):
    try:
        resultN = float(n1.get()) ** (1/float(n2.get()))
        returnValue = [f'\n{n1.get()} ^ (1/{n2.get()}) = {str(resultN)}', resultN]
        return returnValue
    except ValueError:
        return ['\n Error: Are you (root)ing for somone?!', n1.get()]
    
def sine(n1, n2, inverse):
    try:
        if inverse.get():
            resultN = roundToFive(math.asin(float(n1.get())))
            return [f'\nsin-1({n1.get()}) = {resultN}',resultN]
        else:
            resultN = roundToFive(math.sin(float(n1.get())))
            return [f'\nsin({n1.get()}) = {resultN}',resultN]
    except ValueError:
        return ['\n Error: Seriusely, sine-1 only accepts numbers between -1, and 1! Oh, and if your using sine, ITS RADIANS', n1.get()]
    
def cosine(n1, n2, inverse):
    try:
        if inverse.get():
            resultN = roundToFive(math.acos(float(n1.get())))
            return [f'\ncos-1({n1.get()}) = {resultN}',resultN]
        else:
            resultN = roundToFive(math.cos(float(n1.get())))
            return [f'\ncos({n1.get()}) = {resultN}',resultN]
    except ValueError:
        return ['\n Error: What do you even use cosine for, its like a messed up sine!', n1.get()]

def tangent(n1, n2, inverse):
    try:
        if inverse.get():
            resultN = roundToFive(math.atan(float(n1.get())))
            return [f'\ntan-1({n1.get()}) = {resultN}',resultN]
        else:
            resultN = roundToFive(math.cos(float(n1.get())))
            return [f'\ntan({n1.get()}) = {resultN}',resultN]
    except ValueError:
        return ['\n Error: Are you even triing to get the tangent of a number?!', n1.get()]
    
def logarithem(n1,n2,inverse):
    try:
        if inverse.get():
            if n2.get():
                resultN = roundToFive(10**float(n1.get()))
                return [ f'\nlog-1({n1.get()}) = {str(resultN)}', resultN]
            else:
                resultN = roundToFive(math.exp(float(n1.get())))
                return [ f'\nln-1({n1.get()}) = {str(resultN)}', resultN]
        else:
            if n2.get():
                resultN = roundToFive(math.log10(float(n1.get())))
                return [ f'\nlog({n1.get()}) = {str(resultN)}', resultN]
            else:
                resultN = roundToFive(math.log(float(n1.get())))
                return [ f'\nln({n1.get()}) = {str(resultN)}', resultN]
    except ValueError:
        return ['\n Error: Are you triing to be funny here?!', n1.get()]
    except OverflowError:
        return ['\n Error: Uh oh, your numbers are bigger than even the biggest piggy bank can handle! Try using smaller numbers or switching to a bigger bank (like a vault).?!', n1.get()]
def operation(function):
    results = function(num1,num2)
    result.insert(END, results[0])
    result.see(END)
    if accumulate.get():
        if results[1]:
            num1.delete(0, END)
            num1.insert(0, results[1])
def add():
    operation(addition)
addButton = Button(
    master=btnFrame,
    text='Add',
    command=add
).pack(side=LEFT, expand=True)
def subtract():
    operation(subtraction)
subtractButton = Button(
    master=btnFrame,
    text='Subtract',
    command=subtract
).pack(side=LEFT, expand=True)
def multiply():
    operation(multiplication)
multiplicationButton = Button(
    master=btnFrame,
    text='Multiply',
    command=multiply
).pack(side=LEFT, expand=True)
def divide():
    operation(division)
divideButton = Button(
    master=btnFrame,
    text='Divide',
    command=divide
).pack(side=LEFT, expand=True)
def power():
    operation(exponent)
powerButton = Button(
    master=btnFrame,
    text='Exponent',
    command=power
).pack(side=LEFT, expand=True)
def root():
    operation(rooting)
rootButton = Button(
    master=btnFrame,
    text='Root',
    command=root
).pack(side=LEFT, expand=True)
def func(function):
    results = function(num1,num2, inverse)
    result.insert(END, results[0])
    result.see(END)
    if accumulate.get():
        if results[1]:
            num1.delete(0, END)
            num1.insert(0, results[1])
def sines():
    func(sine)
sinButton = Button(
    master=btnFrame2,
    text='Sine',
    command=sines
).pack(side=LEFT, expand=True)
def cosines():
    func(cosine)
cosinButton = Button(
    master=btnFrame2,
    text='Cosine',
    command=cosines
).pack(side=LEFT, expand=True)
def tan():
    func(tangent)
cosinButton = Button(
    master=btnFrame2,
    text='Tangent',
    command=tan
).pack(side=LEFT, expand=True)
def log():
    func(logarithem)

logButton = Button(
    master=btnFrame2,
    text='Logarithm (SecondNumber for log10())',
    command=log
).pack(side=LEFT, expand=True)
btnFrame.pack(side=TOP, fill=X)
btnFrame2.pack(side=TOP, fill=X)
options.pack(side = TOP)
result.pack(fill=X, side=TOP)
window.mainloop()
